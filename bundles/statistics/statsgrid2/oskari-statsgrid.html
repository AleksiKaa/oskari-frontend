<link href="libs/polymer/polymer.html" rel="import">
<!-- TODO: If you start using the libs here in other bundles as well, they must be moved to a shared location. -->
<link href="libs/vaadin-components/vaadin-components.html" rel="import">
<link href="libs/iron-collapse/iron-collapse.html" rel="import">
<link href="requirejs.html" rel="import">

<dom-module id="oskari-statsgrid">

  <template>
    <!-- TODO: If we want to vulcanize all this into one file, that is of course possible.
               See: https://github.com/polymer/vulcanize
    -->
    <iron-ajax
      auto
      url="{{ajaxUrl}}"
      params='{"action_route": "GetLayerInfo"}'
      handle-as="json"
      last-response="{{layerInfo}}"
      debounce-duration="300"
      id="layerInfoAjax"></iron-ajax>
    <div>
      <label for="selectRegionCategory">{{locale.selectRegionCategory}}</label>
      <select id="selectRegionCategory" style="width: 300px;" value="{{selectedLayer::change}}">
        <template is="dom-repeat" items="[[getLayerInfoAsArray(layerInfo)]]">
          <option value="{{item.val}}">{{item.text}}</option>
        </template>
      </select>
      
      <button on-click="toggleStats">Statistics</button>
      <iron-collapse id="statscollapse">
        <vaadin-grid id="indicator-statistics-grid" items="{{statsrows}}"
          indicator-headers="[[indicatorHeaders]]" selecter-layer="[[selectedLayer]]">
          <table>
            <!-- Define the columns -->
            <col name="region" header-text$="[[localize(locale.regionCategories, selectedLayer)]]">
            <template is="dom-repeat" items="[[indicatorHeaders]]" as="header">
              <col name$="[[header.id]]" header-text$="[[header.header]]">
            </template>
          </table>
        </vaadin-grid>
      </iron-collapse>
      <vaadin-grid selection-mode="multi" id="indicator-data-grid" items="{{rows}}"
        indicator-headers="[[indicatorHeaders]]" selecter-layer="[[selectedLayer]]">
        <table>
          <!-- Define the columns -->
          <col name="region" header-text$="[[localize(locale.regionCategories, selectedLayer)]]">
          <template is="dom-repeat" items="[[indicatorHeaders]]" as="header">
            <col name$="[[header.id]]" header-text$="[[header.header]]">
          </template>
        </table>
      </vaadin-grid>
      <content></content>
    </div>
  </template>

  <script>
      Polymer.require(["/Oskari/libraries/mathjs/dist/math.min.js"], function(math) {
          return {
      "is": "oskari-statsgrid",
      "properties": {
          "ajaxUrl": String,
          "locale": Object,
          "language": String,
          "sources": {
              "type": Object,
              "notify": true
          },
          "selectedLayer": {
              "type": String,
              "value": "oskari:kunnat2013",
              "notify": true
          },
          "layerInfo": {
              "type": Object,
              "notify": true
          },
          "regionInfo": {
              "type": Object,
              "notify": true
          },
          "indicatorHeaders": {
              "value": [],
              "type": Array,
              "notify": true
          },
          "rows": {
              "type": Array,
              "notify": true
          },
          "statsrows": {
              "type": Array,
              "notify": true
          },
          "selectedIndicators": {
              "type": Array,
              "notify": true
          }
      },
      "observers": [
          "selectedLayerChanged(ajaxUrl, selectedLayer)",
          "selectedIndicatorsChanged(ajaxUrl, selectedIndicators.splices)"
      ],
      "toggleStats": function() {
          this.$.statscollapse.toggle();
      },
      /**
       * Converts the selector array into selectors key-value object required by the interface.
       */
      "toSelectorsParameter": function(selectorsArray) {
          var selectors = {};
          selectorsArray.forEach(function(selector) {
              selectors[selector.selectorId] = selector.value;
          });
          return selectors;
      },
      "getLayerInfoAsArray": function(layerInfo) {
          var me = this,
              array = [];
          Object.keys(layerInfo).forEach(function(layerName) {
              array.push({
                  "val": layerName,
                  "text": me.localize(me.locale.regionCategories, layerName)
              });
          });
          return array;
      },
      "selectedLayerChanged": function(ajaxUrl, layer) {
          var me = this;
          $.ajax({
              url: me.ajaxUrl,
              data: me.getRegionInfoParams(layer),
              dataType: 'json',
              success: function(results){
                  me.regionInfo = results;
                  Object.keys(me.regionInfo).forEach(function (regionKey) {
                      me.regionInfo[regionKey].localizedName =
                          me.localize(me.locale.regionCategories, me.regionInfo[regionKey].name);
                  });
              }
          });
      },
      "selectedIndicatorsChanged": function(ajaxUrl, splices) {
          var me = this,
            indicators = me.selectedIndicators;
          this.set("indicatorHeaders", indicators.map(function(indicator) {
              var selectors = me.toSelectorsParameter(indicator.selectors),
                  selectorsString = JSON.stringify(selectors),
                  cacheKey = me.getCacheKey(indicator.datasourceId, indicator.indicatorId,
                      me.selectedLayer, selectorsString);
              return {
                  id: cacheKey,
                  indicatorId: indicator.indicatorId,
                  // FIXME: Add selections to the header text.
                  header: me.sources[indicator.datasourceId].indicators[indicator.indicatorId].name[me.language]
              }
          }));
          indicators.forEach(function(indicator) {
              var selectors = me.toSelectorsParameter(indicator.selectors),
                  selectorsString = JSON.stringify(selectors),
                  cacheKey = me.getCacheKey(indicator.datasourceId, indicator.indicatorId,
                      me.selectedLayer, selectorsString);
              if (me.cache[cacheKey]) {
                  me.handleResponse(me.cache[cacheKey]);
              }
              $.ajax({
                  url: me.ajaxUrl,
                  data: {
                      "action_route": "GetIndicatorData",
                      "plugin_id": indicator.datasourceId,
                      "indicator_id": indicator.indicatorId,
                      "layer_id": me.selectedLayer,
                      "selectors": selectorsString
                  },
                  dataType: 'json',
                  success: function(results){
                      me.cache[cacheKey] = results;
                      me.handleResponse(me.cache[cacheKey]);
                  }
              });
          });
      },
      "getRegionInfoParams": function(selectedLayer) {
          var res = {
              "action_route": "GetRegionInfo",
              "layer_id": selectedLayer
          };
          return res;
      },
      "isDefined": function(value) {
          return value !== undefined && value !== null;
      },
      "summarize": {
          "min": function(values) {
              return math.min(values);
          },
          "max": function(values) {
              return math.max(values);
          },
          "avg": function(values) {
              return math.mean(values);
          },
          "mde": function(values) {
              return math.mode(values);
          },
          "mdn": function(values) {
              return math.median(values);
          },
          "std": function(values) {
              return math.std(values);
          },
          "sum": function(values) {
              return math.sum(values);
          }
      },
      "localize": function(prefix, key) {
          return prefix[key] || key;
      },
      "handleResponse": function(response) {
          var me = this,
              regionKeyedValues = {},
              // For average, min, max, etc.
              summaryIds = ["min", "max", "avg", "mde", "mdn", "std", "sum"],
              // An array of {'min': value, 'max': value, ...} objects in the order of indicatorHeaders.
              summariesForIndicators = me.indicatorHeaders.map(function(indicatorHeader) {
                  // In ES6 we should definitely use "const" here.
                  var cacheKey = indicatorHeader.id,
                      indicatorValues = me.cache[cacheKey],
                      values = indicatorValues && Object.keys(indicatorValues).map(function(regionKey) {
                          return indicatorValues[regionKey];
                      }) || [],
                      // In ES6 we could use { [summaryFunction]: ... }
                      summary = {},
                      definedValues = values.filter(me.isDefined);
                  if (definedValues && values.length > 0) {
                      summaryIds.forEach(function(summaryFunction) {
                          summary[summaryFunction] = me.summarize[summaryFunction](definedValues);
                      });
                  }
                  return summary;
              }),
              summaryRows = summaryIds.map(function(summaryFunction) {
                  return [me.locale.statistic[summaryFunction]].concat(
                      summariesForIndicators.map(function(summaryValuesForIndicator) {
                      return summaryValuesForIndicator[summaryFunction];
                  }));
              });

          // Transposing the array keyed by indicators in cache to being keyed by regions.
          me.indicatorHeaders.forEach(function(indicatorHeader) {
              var cacheKey = indicatorHeader.id,
                  indicatorValues = me.cache[cacheKey];
              if (indicatorValues) {
                  Object.keys(indicatorValues).forEach(function(regionKey) {
                      var value = indicatorValues[regionKey];
                      if (!regionKeyedValues[regionKey]) {
                          regionKeyedValues[regionKey] = {};
                      }
                      regionKeyedValues[regionKey][cacheKey] = value;
                  });
              }
          });

          var newRows = Object.keys(regionKeyedValues).map(function(regionKey) {
              var indicatorValues = regionKeyedValues[regionKey],
              
              row = [me.regionInfo[regionKey].localizedName]
                  .concat(me.indicatorHeaders.map(function(indicatorHeader) {
                  return indicatorValues[indicatorHeader.id];
              }));
              return row;
          });
          this.set("statsrows", summaryRows);
          this.set("rows", newRows);
      },
      "getCacheKey": function(datasourceId, indicatorId, selectedLayer, selectorsString) {
          return datasourceId + ":" + indicatorId + ":" + selectedLayer + ":" + selectorsString;
      },
      "ready": function() {
          this.cache = {};
      }
      
    };
  });
  </script>

</dom-module>

