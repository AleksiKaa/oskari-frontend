<link href="libs/polymer/polymer.html" rel="import">
<link href="requirejs.html" rel="import">
<!-- TODO: If you start using the libs here in other bundles as well, they must be moved to a shared location. -->
<link href="libs/iron-ajax/iron-ajax.html" rel="import">
<link href="libs/iron-collapse/iron-collapse.html" rel="import">
<link href="libs/paper-menu/paper-menu.html" rel="import">
<link href="libs/paper-scroll-header-panel/paper-scroll-header-panel.html" rel="import">
<link href="oskari-filter-on-value-dialog.html" rel="import">
<link href="oskari-grid.html" rel="import">
<link href="oskari-spinner.html" rel="import">

<dom-module id="oskari-statsgrid">

  <template>
    <!-- TODO: If we want to vulcanize all this into one file, that is of course possible.
               See: https://github.com/polymer/vulcanize
    -->
    <iron-ajax
      auto
      url="{{ajaxUrl}}"
      params='{"action_route": "GetLayerInfo"}'
      handle-as="json"
      last-response="{{layerInfo}}"
      debounce-duration="300"
      id="layerInfoAjax"
      on-error="ajaxError"></iron-ajax>
    <div id="oskari-stats-data-grid">
      <oskari-spinner visible="[[showSpinner]]" spinnerId="indicatorDataSpinner">
      </oskari-spinner>
      <div id="region-category-selector">
        <label for="selectRegionCategory">{{locale.selectRegionCategory}}</label>
        <select id="selectRegionCategory" style="width: 300px;" value="{{selectedLayer::change}}">
          <template is="dom-repeat" items="[[getLayerInfoAsArray(layerInfo)]]">
            <option value="{{item.val}}">{{item.text}}</option>
          </template>
        </select>
      </div>
      <oskari-grid id="indicator-data-grid" statsrows="[[statsrows]]" rows="{{rows}}" headers="[[rowHeaders]]" selection="1"
        on-sort="onSort" on-filter="onFilter" on-delete="onDelete" filtering sorting deleting="{{!embedded}}" />
      <content></content>
    </div>
  </template>

  <script>
      Polymer.require(["/Oskari/libraries/mathjs/math.2.4.1.min.js"], function(math) {
          return {
      "is": "oskari-statsgrid",
      "properties": {
          "ajaxUrl": String,
          "locale": Object,
          "language": String,
          "embedded": Boolean,
          "sandbox": {
              "type": Object,
              "notify": true
          },
          "sources": {
              "type": Object,
              "notify": true
          },
          "selectedLayer": {
              "type": String,
              "notify": true
          },
          "layerInfo": {
              "type": Object,
              "notify": true
          },
          "regionInfo": {
              "type": Object,
              "notify": true
          },
          "rowHeaders": {
              "value": [],
              "type": Array,
              "notify": true
          },
          "rows": {
              "type": Array,
              "notify": true
          },
          "statsrows": {
              "type": Array,
              "notify": true
          },
          "selectedIndicators": {
              "type": Array,
              "notify": true
          },
          /**
           * For example the indicator selector can notify of selected indicator with this.
           */
          "selectorSelectedIndicatorKey": {
              "type": String,
              "notify": true
          },
          /**
           * For example the indicator selector can notify of selected indicator with this.
           */
          "selectedIndicatorKey": {
              "type": String,
              "notify": true
          },
          /**
           * This designates the indicator that is currently active in the map.
           */
          "selectedIndicator": {
              "type": Object,
              "notify": true
          },
          "showSpinner": {
            "type": Boolean,
            "notify": true,
            "value": false
          }
      },
      "listeners": {
          "onSort": "onSort",
          "onDelete": "onDelete",
          "onFilter": "onFilter"
      },
      "observers": [
          "selectedLayerChanged(ajaxUrl, selectedLayer)",
          "selectedIndicatorsChanged(ajaxUrl, selectedIndicators.splices, sources, selectedIndicators)",
          "sortChanged(sortColumnIdx, sortDirection)",
          "updateSelectedIndicators(sources)",
          "selectedIndicatorChanged(selectedIndicatorKey, cache)"
      ],
      "ajaxError": function(e) {
        var me = this;
        console.log("Error: " + e);
        window.alert(me.locale.connectionError + ": " + e);
      },
      "sendTooltipData": function(feature) {
          var featureAttributes = feature.attributes,
              regionCode = featureAttributes[this.layerInfo[this.selectedLayer].idTag],
              eventBuilder = this.sandbox.getEventBuilder(
                  'MapStats.HoverTooltipContentEvent'
              ),
              item = this.selectedIndicator.data[regionCode],
              content;

          if (item === null || item === undefined) {
              this.sandbox.printWarn(
                  'sendTooltipData: item not found for',
                  regionCode,
                  'in',
                  this.selectedIndicator.data
              );
          }

          content = '<p>' + this.regionInfo[regionCode].localizedName;
          content += item ? '<br />' + item : '';
          content += '</p>';

          if (eventBuilder) {
              var event = eventBuilder(content);
              this.sandbox.notifyAll(event);
          }
      },
      "showIndicatorOnMap": function(cacheKey, index, header) {
          var me = this,
              eventBuilder = me.sandbox.getEventBuilder('StatsGrid.StatsDataChangedEvent'),
              indicatorValues = me.cache[cacheKey],
              cur_col = {
                  // TODO: This is a legacy code workaround. Now unnecessary, but the classification plugin wants it.
                  field: "indicator: " + (header && header.title || header)
              },
              vis_name = me.selectedLayer,
              vis_attr = me.layerInfo[me.selectedLayer].idTag,
              vis_codes = indicatorValues && Object.keys(indicatorValues) || [],
              col_values = vis_codes.map(function(regionKey) {
                  return indicatorValues[regionKey];
              });
          me.set("selectedIndicatorKey", cacheKey);
          if (eventBuilder) {
              // CUR_COL:"indicator..." , VIS_NAME: "ows:kunnat2013", VIS_ATTR: "kuntakoodi", VIS_CODES: munArray, COL_VALUES: statArray
              var data = {
                  CUR_COL: cur_col,
                  VIS_NAME: vis_name,
                  VIS_ATTR: vis_attr,
                  VIS_CODES: vis_codes,
                  COL_VALUES: col_values
              },
              // Oskari.mapframework.domain.WmsLayer
              // layertype STATS
                  layer = me.sandbox.findMapLayerFromAllAvailable(null, me.selectedLayer),
                  event = eventBuilder(layer, data);
              me.sandbox.notifyAll(event);
          }
      },
      "onSort": function(event) {
          var id = event.target.id,
            index = event.detail.index,
            header = event.detail.header;
          this.selectedIndicatorKey = header.id;
          if (id === "indicator-data-grid") {
              // The statistics summary grid is not sortable.
              this.sortBasedOnColumn(index);
              // This also selects the indicator into the map.
              this.showIndicatorOnMap(header.id, index, header);
          }
      },
      "onDelete": function(event) {
          var id = event.target.id,
            index = event.detail.index,
            header = event.detail.header;
          this.deleteIndicator(index - 1);
      },
      "onFilter": function(event) {
          var id = event.target.id,
            index = event.detail.index,
            header = event.detail.header;
          this.filterOnValue(index);
      },
      "selectedIndicatorChanged": function(indicatorKey) {
          var me = this,
              indicatorHeader,
              i = 0,
              index;
          me.rowHeaders.forEach(function (header) {
              if (header.id === indicatorKey) {
                  indicatorHeader = header;
                  index = i;
              }
              i = i + 1;
          });
          if (!indicatorHeader) {
              return;
          }
          me.set("selectedIndicator", {
              header: indicatorHeader,
              data: me.cache[indicatorHeader.id]
          });
          this.showIndicatorOnMap(indicatorHeader.id, index, indicatorHeader);
          this.updateSize();
      },
      "filterOnValue": function(index) {
          var me = this;
          var filterDialog = document.createElement("oskari-filter-on-value-dialog");
          me.dialogs.push(filterDialog);
          filterDialog.locale = me.locale;
          filterDialog.label = me.rowHeaders[index].title;
          filterDialog.id = "filterDialog";
          filterDialog.columnId = me.rowHeaders[index].id;
          filterDialog.columnIndex = index;
          filterDialog.rows = me.rows;
          filterDialog.onClose = function() {
              me.dialogs.forEach(function(dialog) {
                  // In some cases if you click filtering many times, the other dialogs linger around invisible.
                  // This removes them all.
                  dialog.remove();
              });
              me.dialogs = [];
              me.$["indicator-data-grid"].selectionsChanged();
          };
          me.appendChild(filterDialog);
      },
      /**
       * Converts the selector array into selectors key-value object required by the interface.
       */
      "toSelectorsParameter": function(selectorsArray) {
          var selectors = {};
          selectorsArray.forEach(function(selector) {
              selectors[selector.selectorId] = selector.value;
          });
          return selectors;
      },
      "getLayerInfoAsArray": function(layerInfo) {
          var me = this,
              array = [];
          Object.keys(layerInfo).forEach(function(layerId) {
              array.push({
                  "val": layerId,
                  "text": me.localize(me.locale.regionCategories, layerId)
              });
          });
          return array;
      },
      "selectedLayerChanged": function(ajaxUrl, layer) {
          var me = this;
          $.ajax({
              url: me.ajaxUrl,
              data: me.getRegionInfoParams(layer),
              dataType: 'json',
              success: function(results){
                  me.regionInfo = results;
                  Object.keys(me.regionInfo).forEach(function (regionKey) {
                      me.regionInfo[regionKey].localizedName =
                          me.localize(me.locale.regionCategories, me.regionInfo[regionKey].name);
                  });
                  me.selectedIndicatorsChanged();
              },
              error: function(jqXHR, textStatus, errorThrown) {
                console.log("Error: " + textStatus + ", " + errorThrown);
                window.alert(me.locale.connectionError + ": " + textStatus);
              }
          });
          var statsLayer = me.sandbox.findMapLayerFromAllAvailable(null, layer);
          if (statsLayer) {
            statsLayer.setVisible(true);
          }
      },
      "selectedIndicatorsChanged": function() {
          var me = this,
              indicators = this.selectedIndicators || [];
          // This is needed to initialize the native dropdown to the correct value.
          this.$.selectRegionCategory.value = this.selectedLayer;
          this.set("rowHeaders", [{
              title: me.localize(me.locale.regionCategories, me.selectedLayer),
              sort: true,
              filter: true
          }].concat(
              indicators.map(function(indicator) {
                  var selectors = me.toSelectorsParameter(indicator.selectors),
                      selectorsKey = JSON.stringify(selectors),
                      cacheKey = me.getCacheKey(indicator.datasourceId, indicator.indicatorId,
                          me.selectedLayer, selectorsKey),
                      selectorsAsString = indicator.selectors.map(function(selector) {
                          return selector.value;
                      }).join("/");
                  indicator.id = cacheKey;
                  if (indicator.indicatorValues) {
                    // This is a published indicator in an embedded view with inlined data.
                    return {
                      id: cacheKey,
                      indicatorId: indicator.indicatorId,
                      title: indicator.title[me.language]
                        + ((selectorsAsString.length > 0) ? "/" : "") + selectorsAsString,
                      sort: true,
                      filter: true,
                      delete: true
                    }
                  }
                  return {
                      id: cacheKey,
                      indicatorId: indicator.indicatorId,
                      title: me.sources[indicator.datasourceId].indicators[indicator.indicatorId].name[me.language]
                        + ((selectorsAsString.length > 0) ? "/" : "") + selectorsAsString,
                      sort: true,
                      filter: true,
                      delete: true
                  }
          })));
          var ajaxCallMade = false;
          indicators.forEach(function(indicator) {
              var selectors = me.toSelectorsParameter(indicator.selectors),
                  selectorsString = JSON.stringify(selectors),
                  cacheKey = me.getCacheKey(indicator.datasourceId, indicator.indicatorId,
                      me.selectedLayer, selectorsString);
              if (me.cache[cacheKey]) {
                  me.handleResponse(me.cache[cacheKey]);
                  return;
              } else if (indicator.indicatorValues) {
                  // This is a published indicator in an embedded view with inlined data.
                  me.cache[cacheKey] = indicator.indicatorValues;
                  return;
              }
              ajaxCallMade = true;
              $.ajax({
                  url: me.ajaxUrl,
                  data: {
                      "action_route": "GetIndicatorData",
                      "plugin_id": indicator.datasourceId,
                      "indicator_id": indicator.indicatorId,
                      "layer_id": me.selectedLayer,
                      "selectors": selectorsString
                  },
                  dataType: 'json',
                  success: function(results) {
                      me.showSpinner = false;
                      me.cache[cacheKey] = results;
                      me.handleResponse(me.cache[cacheKey]);
                  },
                  error: function(jqXHR, textStatus, errorThrown) {
                    console.log("Error: " + textStatus + ", " + errorThrown);
                    window.alert(me.locale.connectionError + ": " + textStatus);
                    me.showSpinner = false;
                  }
              });
          });
          if (ajaxCallMade) {
              me.showSpinner = true;
          }
      },
      "getRegionInfoParams": function(selectedLayer) {
          var res = {
              "action_route": "GetRegionInfo",
              "layer_id": selectedLayer
          };
          return res;
      },
      "isDefined": function(value) {
          return value !== undefined && value !== null;
      },
      "summarize": {
          "min": function(values) {
              return math.min(values);
          },
          "max": function(values) {
              return math.max(values);
          },
          "avg": function(values) {
              return math.mean(values);
          },
          "mde": function(values) {
              return math.mode(values);
          },
          "mdn": function(values) {
              return math.median(values);
          },
          "std": function(values) {
              return math.std(values);
          },
          "sum": function(values) {
              return math.sum(values);
          }
      },
      "localize": function(prefix, key) {
          return prefix[key] || key;
      },
      "deleteIndicator": function(index) {
          // FIXME: When indicators are deleted, the selected indicator on the map should be changed also
          //        so that it will not be an indicator that was deleted.
          this.splice("rowHeaders", index + 1, 1);
          this.splice("selectedIndicators", index, 1);
      },
      "onDeleteIndicator": function(event) {
          var me = this,
              // The first index is the header column.
              index = event.target.index - 1;
          this.deleteIndicator(index);
      },
      "handleResponse": function(response) {
          var me = this;
          if (!me.selectedIndicators.every(function(indicator) {
                  // TODO: This would be cleaner using promises.
                  // If we haven't fetched all the indicator values yet, we will do nothing.
                  return me.cache[indicator.id] != undefined;
              })) {
              return;
          }
          var
              regionKeyedValues = {},
              // For average, min, max, etc.
              summaryIds = ["min", "max", "avg", "mde", "mdn", "std", "sum"],
              // An array of {'min': value, 'max': value, ...} objects in the order of selectedIndicators.
              summariesForIndicators = me.selectedIndicators.map(function(indicator) {
                  // In ES6 we should definitely use "const" here.
                  var cacheKey = indicator.id,
                      indicatorValues = me.cache[cacheKey],
                      values = indicatorValues && Object.keys(indicatorValues).map(function(regionKey) {
                          return indicatorValues[regionKey];
                      }) || [],
                      // In ES6 we could use { [summaryFunction]: ... }
                      summary = {},
                      definedValues = values.filter(me.isDefined);
                  // FIXME: Filter based on selected value
                  if (definedValues && values.length > 0) {
                      summaryIds.forEach(function(summaryFunction) {
                          summary[summaryFunction] = me.summarize[summaryFunction](definedValues);
                      });
                  }
                  return summary;
              }),
              summaryRows = summaryIds.map(function(summaryFunction) {
                  return {
                      selected: true,
                      data: [me.locale.statistic[summaryFunction]].concat(
                              summariesForIndicators.map(function(summaryValuesForIndicator) {
                          return summaryValuesForIndicator[summaryFunction];
                      }))
                  };
              });

          // Transposing the array keyed by indicators in cache to being keyed by regions.
          me.selectedIndicators.forEach(function(indicator) {
              var cacheKey = indicator.id,
                  indicatorValues = me.cache[cacheKey];
              if (indicatorValues) {
                  Object.keys(indicatorValues).forEach(function(regionKey) {
                      var value = indicatorValues[regionKey];
                      if (!regionKeyedValues[regionKey]) {
                          regionKeyedValues[regionKey] = {};
                      }
                      regionKeyedValues[regionKey][cacheKey] = value;
                  });
              }
          });

          var newRows = Object.keys(regionKeyedValues).map(function(regionKey) {
              var indicatorValues = regionKeyedValues[regionKey],
              
              row = {
                  selected: true,
                  data: ((me.regionInfo[regionKey]) && [me.regionInfo[regionKey].localizedName] ||
                        [me.localize(me.locale, "defunctRegion") + " (" + regionKey + ")"])
                      .concat(me.selectedIndicators.map(function(indicator) {
                          return indicatorValues[indicator.id];
                  }))
              };
              return row;
          });
          this.set("statsrows", summaryRows);
          this.set("rows", newRows);
          if (me.selectedIndicators.length === 1 || (me.embedded && me.selectedIndicators.length > 0)) {
              // If this is the first added indicator, or the only indicator left, we will update the map.
              // We will also update the map if we are in embedded mode, because we can fetch several indicators at once, and the first
              // indicator check will in that case fail.
              var theOnlyIndicator = me.selectedIndicators[0];
              me.selectedIndicatorChanged(theOnlyIndicator.id);
          }
      },
      "getCacheKey": function(datasourceId, indicatorId, selectedLayer, selectorsString) {
          return datasourceId + ":" + indicatorId + ":" + selectedLayer + ":" + selectorsString;
      },
      "sortIndicatorDataGrid": function (idx, direction) {
          var me = this;
          return function(a, b) {
              var lesser = direction == 'asc' ? -1 : 1;
              // Ambiguous order, using region name order.
              if (((a.data[idx] === undefined) && (b.data[idx] === undefined)) ||
                  (a.data[idx] === b.data[idx])) {
                  return me.sortIndicatorDataGrid(0, direction)(a, b);
              }
              // Undefined values are considered the smallest.
              if (a.data[idx] === undefined) {
                  return lesser;
              } else if (b.data[idx] === undefined) {
                  return -lesser;
              }
              return (a.data[idx] < b.data[idx]) ? lesser : -lesser;
          };
      },
      "sortChanged": function() {
          var me = this;
          me.rows.sort(me.sortIndicatorDataGrid(me.sortColumnIdx, me.sortDirection));
          // TODO: It might be a bit cleaner to use Polymer repeat element sort functionality here.
          this.$["indicator-data-grid"].refresh();
      },
      "sortBasedOnColumn": function(idx) {
          if (this.sortColumnIdx === idx) {
              this.sortDirection = this.sortDirection == "asc" ? "desc" : "asc";
          } else {
              this.sortDirection = "asc";
          }
          this.sortColumnIdx = idx;
      },
      "updateSelectedIndicators": function(sources) {
        if (sources) {
          this.selectedIndicatorsChanged(this.ajaxUrl, this.selectedIndicators);
        }
      },
      "updateSize": function() {
          var windowHeight = jQuery(window).height();
          var catSelHeight = jQuery('#region-category-selector').height();
          var indSelHeight = jQuery('#indicatorSelectorDiv').height();
          jQuery('#oskariGrid').height( windowHeight - catSelHeight
        		  - indSelHeight);
          jQuery('#oskari-grid-panel').height(windowHeight - catSelHeight
        		  - indSelHeight);
          jQuery('#oskari-stats-data-grid').height(windowHeight
        		  - indSelHeight);
      },
      "attached": function() {
          var me = this;
          if (this.embedded && this.selectedIndicators && this.selectedIndicators.length > 0) {
            var indicatorKey = this.selectedIndicators[0].id;
            this.set("selectedIndicator", this.selectedIndicators[0]);
            this.set("selectedIndicatorKey", indicatorKey);
          }
          this.updateSize();
      },
      "ready": function() {
          this.cache = {};
          this.dialogs = [];
      }
    };
  });
  </script>

</dom-module>

